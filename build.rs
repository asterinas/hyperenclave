// Copyright (C) 2023 Ant Group CO., Ltd. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::fs::{metadata, read_to_string, File};
use std::io::{Error, ErrorKind};
use std::io::{Result, Write};
use std::path::PathBuf;
use std::process::Command;

fn main() -> Result<()> {
    gen_vector_asm()?;

    gen_version(get_version("../rust-hypervisor/VERSION")?, "version.rs")?;

    build_trust_lib();
    Ok(())
}

/// Generate assembly file for x86_64 trap vector
fn gen_vector_asm() -> Result<()> {
    let out_path = PathBuf::from(std::env::var("OUT_DIR").unwrap());
    let mut f = File::create(out_path.join("exception.S"))?;

    writeln!(f, "# generated by build.rs - do not edit")?;
    writeln!(f, ".section .text")?;
    for i in 0..256 {
        writeln!(f, "__entry{}:", i)?;
        if !(i == 8 || (10..=14).contains(&i) || i == 17) {
            writeln!(f, "\tpush 0")?;
        }
        writeln!(f, "\tpush {}", i)?;
        writeln!(f, "\tjmp common_exception_entry")?;
    }

    writeln!(f, "\n.section .rodata")?;
    writeln!(f, ".global exception_entries")?;
    writeln!(f, "exception_entries:")?;
    for i in 0..256 {
        writeln!(f, "\t.quad __entry{}", i)?;
    }
    Ok(())
}

fn get_version(filename: &str) -> Result<u32> {
    if metadata(filename).is_err() {
        return Err(Error::new(
            ErrorKind::NotFound,
            format!("Fail to find {:?}", filename),
        ));
    }
    let vstr = read_to_string(filename)?;

    if !vstr.starts_with('v') {
        return Err(Error::new(
            ErrorKind::InvalidData,
            "Invalid version format. Should be va.b.c",
        ));
    }

    let mut subversion = vstr[1..].trim().split('.');
    let a: u8 = subversion.next().unwrap().parse().unwrap();
    let b: u8 = subversion.next().unwrap().parse().unwrap();
    let c: u8 = subversion.next().unwrap().parse().unwrap();

    Ok(c as u32 | ((b as u32) << 8) | ((a as u32) << 16))
}

fn gen_version(version: u32, version_rs_filename: &str) -> Result<()> {
    let out_path = PathBuf::from(std::env::var("OUT_DIR").unwrap());
    let mut f = File::create(out_path.join(version_rs_filename))?;
    writeln!(f, "#[allow(dead_code)]")?;
    writeln!(f, "const RUST_HYPERVISOR_VERSION: u32 = {:#x};", version)?;
    Ok(())
}

fn build_trust_lib() {
    Command::new("make").args(&["-C", "lib"]).status().unwrap();
    println!("cargo:rustc-link-search=native=lib");
    println!("cargo:rustc-link-lib=static=tpm");
}
